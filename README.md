# database_project
1) ### Тема
   В прошлом семестре в качесве дз нам задали проект, 
   который я делал в спешке.
   
   Из-за спешки я не продумал структуру бд, там есть 
   моменты которые меня смущают. Было бы круто в рамках этого 
   задания перепроектировать схему бд, и посмотреть, что получится.
   
   Идея проекта заключалась в том, чтобы создавать правила для 
   парсинга разных сайтов.
2) ### Концептуальная схема
   ![alt text](images/концептуальная_схема.jpg "Title")
   Тут следует дать пояснения:

   **Endpoint** - ручка, которую мы будем дергать, чтобы получить ```html```, 
   который в последствии будем парсить.
   
   **Endpoint** будет содержать поля *url*, *headers*, *params*
   
   ```Parser``` (Говорим сейчас не про модель с рисунка, 
   а в целом про то что это такое) - это объект, который 
   принимает при инициализации некоторую информацию, которая 
   частично определяет его поведение. Так-же этот обьект имеет метод 
   ```parse```, который принимает на вход данные, как-то их обрабатывает,
   и на выход отдает обработанные данные.
   
   Парсеры могут быть абсолютно разные, но в данном проекте рассмотрим
   ```BS4Parer``` и ```RegexpParser```. 

   ```BS4Parser``` основан на
   библиотеке для удобного парсинга ```html``` 
   [BeautifulSoup](https://beautiful-soup-4.readthedocs.io/en/latest/).
   Данный парсер при инициализации будет принимат аргументы, которые
   можно передать в функцию парсинга, например имя тега, 
   который нужно найти, или имя html-класса, который должен присутствовать.
   
   ```RegexpParser``` основан на регулярках, при инициализации будет
   принимать строку - регулярку.

   И тут у меня возникает вопрос.
   Как правильно все это спроектировать в бд?
   Сложность в том, что ```BS4Parser``` и ```RegexpParser``` имеют разный
   набор аттрибутов, то есть в обну таблицу в бд их не запихать. Я разнес
   их по разным одноименных таблицам, и сделал третью таблицу - **Parser**,
   которая будет содержать тип парсера (```regexp```  или ```bs4```) и его
   ```id``` в соответствующей таблице. Теперь в других моделях можно
   ссылаться на модель **Parser** вне зависимости от типа парсера. Но 
   модели **BS4Parser** и **RegexpParser** "болтаются" отдельно, что мне
   не очень нравиться.
3) **Rule** - эта сущность содержит всю информацию о том, что нужно
   сделать, а именно какую ручку дернуть (**Endpoint**) и как 
   распарсить полученные данные (ноль, один, 
   или несколько парсеров, через которые нужно прогнать данные)
4) **User** - пользователи.
   
   Содержит необходимую инфу о пользователе.

   Пользователи могут добавлять правила в избранное
   